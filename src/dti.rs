include!(concat!(env!("OUT_DIR"), "/dti_generated.rs"));

#[allow(non_camel_case_types)]
#[derive(strum::FromRepr, Debug)]
#[repr(u32)]
pub enum PropType {
    undefined = 0,
    class,
    classref,
    bool,
    u8,
    u16,
    u32,
    u64,
    s8,
    s16,
    s32,
    s64,
    f32,
    f64,
    string,
    color,
    point,
    size,
    rect,
    matrix44,
    vector3,
    vector4,
    quaternion,
    property,
    event,
    group,
    pagebegin,
    pageend,
    event32,
    array,
    propertylist,
    groupend,
    cstring,
    time,
    float2,
    float3,
    float4,
    float3x3,
    float4x3,
    float4x4,
    easecurve,
    line,
    linesegment,
    ray,
    Plane,
    sphere,
    capsule,
    aabb,
    obb,
    cylinder,
    triangle,
    cone,
    torus,
    ellpsoid,
    range,
    rangef,
    rangeu16,
    hermitecurve,
    enumlist,
    float3x4,
    linesegment4,
    aabb4,
    oscillator,
    variable,
    vector2,
    matrix33,
    rect3d_xz,
    rect3d,
    rect3d_collision,
    plane_xz,
    ray_y,
    pointf,
    sizef,
    rectf,
    event64,

    type_end,
    custom = 0x80, // assumed
}

impl From<u32> for PropType {
    fn from(value: u32) -> Self {
        if value >= Self::type_end as u32 {
            Self::custom
        } else {
            Self::from_repr(value).expect("this should never fail!")
        }
    }
}

pub const PROP_ATTR_ARRAY: u32 = 32;
pub const PROP_ATTR_DYNAMIC: u32 = 128;

#[derive(Debug)]
pub struct DTI {
    name: &'static str,
    hash: u32,
    file_ext: Option<&'static str>,
}

impl PartialEq for DTI {
    fn eq(&self, other: &Self) -> bool {
        if self.hash == other.hash {
            self.name == other.name
        } else {
            false
        }
    }
}

impl DTI {
    pub fn from_str(name: &str) -> Option<&'static Self> {
        generated::DTI_MAP.values().find(|d| d.name() == name)
    }

    pub fn from_hash(hash: u32) -> Option<&'static Self> {
        generated::DTI_MAP.get(&hash)
    }

    pub fn name(&self) -> &str {
        self.name
    }

    pub fn hash(&self) -> u32 {
        self.hash
    }

    pub fn file_ext(&self) -> Option<&str> {
        self.file_ext
    }

    pub fn is_type_of(&self, dti: &DTI) -> bool {
        if self == dti {
            return true;
        };

        // need to implement parent stuff in build script
        todo!("check parents")
    }
}

#[test]
fn test_from_hash() {
    assert_eq!(
        &generated::bitset_prop_32_,
        DTI::from_hash(0x5d5af4f2).unwrap()
    );
}

#[test]
fn test_file_ext() {
    assert_eq!(Some("arc"), generated::rArchive.file_ext());
    assert_eq!(None, generated::bitset_prop_32_.file_ext());
}

#[test]
fn test_dti_eq() {
    assert_ne!(generated::MtObject, generated::rArchive);
    assert_eq!(generated::rArchive, generated::rArchive);
}

#[test]
fn test_dti_hashes() {
    use crate::crc32;

    // Make sure the hashes match up with the names
    for (hash, dti) in generated::DTI_MAP.entries() {
        let hash_computed = crc32(dti.name().as_bytes(), u32::MAX) & 0x7fffffff;
        assert_eq!(
            *hash,
            dti.hash(),
            "'{}' {:08x} != {:08x}",
            dti.name(),
            hash,
            hash_computed
        ); // generated by the build script, should always match

        assert_eq!(
            *hash,
            hash_computed,
            "'{}' {:08x} != {:08x}",
            dti.name(),
            hash,
            hash_computed
        )
    }
}
