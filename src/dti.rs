include!(concat!(env!("OUT_DIR"), "/dti_generated.rs"));

#[derive(Debug)]
pub struct DTI {
    name: &'static str,
    hash: u32,
    file_ext: Option<&'static str>,
}

impl PartialEq for DTI {
    fn eq(&self, other: &Self) -> bool {
        if self.hash == other.hash {
            self.name == other.name
        } else {
            false
        }
    }
}

impl DTI {
    pub fn from_hash(hash: u32) -> Option<&'static Self> {
        generated::DTI_MAP.get(&hash)
    }

    pub fn name(&self) -> &str {
        self.name
    }

    pub fn hash(&self) -> u32 {
        self.hash
    }

    pub fn file_ext(&self) -> Option<&str> {
        self.file_ext
    }
}

#[test]
fn test_from_hash() {
    assert_eq!(
        &generated::bitset_prop_32_,
        DTI::from_hash(0x5d5af4f2).unwrap()
    );
}

#[test]
fn test_file_ext() {
    assert_eq!(Some("arc"), generated::rArchive.file_ext());
    assert_eq!(None, generated::bitset_prop_32_.file_ext());
}

#[test]
fn test_dti_eq() {
    assert_ne!(generated::MtObject, generated::rArchive);
    assert_eq!(generated::rArchive, generated::rArchive);
}

#[test]
fn test_dti_hashes() {
    use crate::crc32;

    // Make sure the hashes match up with the names
    for (hash, dti) in generated::DTI_MAP.entries() {
        let hash_computed = crc32(dti.name().as_bytes(), u32::MAX) & 0x7fffffff;
        assert_eq!(
            *hash,
            dti.hash(),
            "'{}' {:08x} != {:08x}",
            dti.name(),
            hash,
            hash_computed
        ); // generated by the build script, should always match

        assert_eq!(
            *hash,
            hash_computed,
            "'{}' {:08x} != {:08x}",
            dti.name(),
            hash,
            hash_computed
        )
    }
}
